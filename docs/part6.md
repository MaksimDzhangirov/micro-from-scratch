# Создаём систему микросервисов с нуля — коммит 6

[Оригинал](https://medium.com/@alexis.tadifo/build-a-microservices-system-from-scratch-commit-6-57729da65c1f)

В [последнем коммите](https://medium.com/@alexis.tadifo/build-a-microservices-system-from-scratch-commit-5-d496a153684)
мы начали с клиентской части нашей системы. Мы инициализировали репозиторий 
с кодом.

> Начиная с этого коммита, наш подход будет заключаться в передаче потока мыслей
> вместо предоставления некоего структурированного резюме того, что мы сделали.

![intro](images/part6/0_dtOROwlgHFgvCsUO.jpeg)

Фото [Tachina Lee](https://unsplash.com/@chne_) из [Unsplash](https://unsplash.com/)

## С чего начать?

На этом этапе мы можем сделать многое:

* выбрать [шаблон для фронтенда](https://github.com/SanAlexis/hiryx/issues/3);
* создать [CI-архитектуру](https://github.com/SanAlexis/hiryx/issues/4) фронтенд части (под названием App);
* создать [CD-архитектуру](https://github.com/SanAlexis/hiryx/issues/5) фронтенд части; а также
* спроектировать, как фронтенд будет развиваться со временем.

Мы можем пойти по такому пути: _Проектирование фронтенда_ => _Шаблон фронтенда_ =>
_CI архитектура_ => _CD архитектура_.

Код доступен здесь: [https://github.com/SanAlexis/hiryx](https://github.com/SanAlexis/hiryx)

## Проектируем фронтенд

Фронтенд — это взаимодействие с пользователем и отображение бэкенд результатов.
На данном этапе нашего проекта проектировать фронтенда, не имея представления о
том, что нужно пользователю, не зная то, что мы будем отображать, заключается 
в ответе на несколько вопросов:

* **Насколько часто мы будем обновлять фронтенд?** Должны ли мы позволить 
  пользователю выбирать, какую версию он хочет запускать, или мы должны 
  обновлять все экземпляры приложения как можно быстрее?
* **Что делать с доступом в Интернет?** Разрешаем ли мы пользователям работать с 
  приложением даже при отсутствии доступа в Интернет или не позволяем системе 
  работать без подключения?
* **Что делать с требованиями, появляющимися на ходу?** Какую стратегию 
  использовать, чтобы реализовать любую новую идею в ходе разработки?
* **Как мы осуществляем разделение между уровнем бизнес логики и представления?** 
  Это важное решение, если мы полностью разделяем эти уровни.
* **Каковы наши основные характеристики?** Несмотря на то, что мы остаемся 
  открытыми для любых изменений, все еще есть возможность определить 
  фундаментальную область применения нашего фронтенда.

## Подход к обновлению фронтенда

_=> Преимущества, когда обновления, контролируются пользователями_

* Пользователи могли решить, нравится ли им новая версия (да, люди любят 
  сами решать стоит ли им использовать её или нет).
* Мы можем оценить, насколько людям нравится конкретная версия.
* Мы можем проводить A/B-тестирование с разными версиями.
* Мы можем создавать версии фронтенда с низкой пропускной способностью.

_=> Преимущества, когда обновления, контролируются командой разработчиков_

* Нам нужно поддерживать сразу несколько версий кода, что требует дополнительных
  временных и денежных инвестиций.
* Нам нужно хранить на сервере несколько версий кода, таким образом, 
  вкладывая больше денег.
* Мы потеряем некоторую гибкость в том, как мы обрабатываем API вызовы с 
  фронтенда. Нам нужно будет гарантировать, что каждый раз, когда мы обновляем 
  контроллеры сервиса, мы не нарушаем работу других версий фронтенда.
  
**Решение** => _мы позволим пользователям выбирать версию фронтенда._

## Реализация работы в офлайн режиме

Мы позволим пользователю работать с приложением в офлайн режиме. Причин тому 
несколько:

* людям, как правило, нравятся приложения, которые не потребляют слишком много 
  трафика;
* часто в течение дня у нас может не быть подключения к Интернету, поэтому 
  всегда полезно не зависеть от доступа в Интернет;
* создавать приложения, которые могли бы использовать все на Земле, это всегда 
  вызов!!

## Требования, появляющиеся на ходу

Для любой новой идеи мы разработаем новую версию фронтенда для ее реализации.
Вот так вот просто.

## Разделение между уровнем бизнес логики и интерфейсным уровнем

Эта часть является наиболее важной, поскольку нам необходимо обеспечить строгое 
разделение между уровнем представления и бизнес логики. На данный момент нет 
ничего конкретного сказать не могу, кроме того, чтобы напоминать об этом 
подходе на протяжении всего проекта.

## Основные характеристики

* Устройства | Ноутбук/рабочая станция
* Минимальное разрешение | 1024x768
* Браузеры | Chrome, Safari, Firefox
* Языки | английский
* Работа в офлайн режиме | Да
* Возможность использования людьми с ограниченными возможностями | Нет (к 
  сожалению, мы не можем себе это позволить)
* SEO | Нет

> В следующем коммите мы выберем шаблон фронтенда и создадим CI архитектуру.

_Алексис С. ТАДИФО_

***

**Ссылки и книги**

* [https://www.telerik.com/blogs/planning-front-end-javascript-application](https://www.telerik.com/blogs/planning-front-end-javascript-application)
* [https://budibase.com/blog/how-to-make-a-web-app/](https://budibase.com/blog/how-to-make-a-web-app/)
* [https://www.dignited.com/56106/apps-that-work-without-internet-connection/](https://www.dignited.com/56106/apps-that-work-without-internet-connection/)
* [https://medium.com/front-end-weekly/create-an-app-that-works-without-the-internet-f07f64d8a62e](https://medium.com/front-end-weekly/create-an-app-that-works-without-the-internet-f07f64d8a62e)