# Микросервисы и первый закон распределенных объектов

13 августа 2014

![Martin Fowler](images/microservices/mf.jpg)

[Мартин Фаулер](https://martinfowler.com/)

[ПРОЕКТИРОВАНИЕ API](https://martinfowler.com/tags/API%20design.html)
[МИКРОСЕРВИСЫ](https://martinfowler.com/tags/microservices.html)

Когда я писал книгу [Шаблоны корпоративных приложений](https://martinfowler.com/books/eaa.html), я придумал то, 
что я назвал **Первым законом проектирования распределенных объектов: «не распределяйте
свои объекты»**. В последние месяцы к микросервисам проявился большой интерес, 
что побудило некоторых людей задаться вопросом, не противоречат ли [микросервисы](https://martinfowler.com/articles/microservices.html) 
этому закону, и если да, то почему я за них?

Важно отметить, что в этом первом утверждении закона я использую фразу 
«распределенные объекты». Это отражает идею, которая была в моде в конце 
90-х — начале 00-х, но с тех пор (правильно) потеряла популярность. Идея 
распределенных объектов заключается в том, что вы можете проектировать объекты 
и выбирать, использовать ли эти объекты либо внутри процесса, либо удаленно, 
где удаленно может означать другой процесс на том же компьютере или на 
другом компьютере. Продуманное middleware, такое как DCOM или реализация 
CORBA, будет нивелировать различие между внутренним и удаленным процессами,
чтобы ваша система могла быть написана, и вы могли разбить ее на процессы 
независимо от того, как было разработано приложение.

Моя неприязнь к понятию распределенных объектов заключалось в том, что, хотя вы 
можете инкапсулировать многие вещи за границами объекта, вы не можете 
инкапсулировать различие удаленного/внутрипроцессного вызова. Вызов 
внутрипроцессной функции выполняется быстро и всегда завершается успешно (в 
том смысле, что любые исключения связаны с приложением, а не с самим фактом 
выполнения вызова). Удаленные вызовы, однако, на несколько порядков медленнее, 
и всегда есть шанс, что вызов завершится ошибкой из-за сбоя в удаленном 
процессе или соединении.

![local-remote](images/Microservices%20and%20the%20First%20Law%20of%20Distributed%20Objects/local-remote.png)

Следствием этого различия является то, что ваши рекомендации для API 
отличаются. Вызовы в процессе могут быть детализированы, если вам нужны 100 цен 
на товары и наличие, вы можете с радостью сделать 100 вызовов функции цен на 
товары и еще 100 для доступности. Но если эта функция является удаленным 
вызовом, вам обычно лучше объединить все это в один вызов, который запрашивает 
все 100 цен и наличия за один раз. Результатом является совершенно другой 
интерфейс для вашего объекта-товара. Следовательно, вы не можете взять один и 
тот же класс (что в первую очередь относится к интерфейсу) и использовать 
его прозрачно внутри процесса или удаленно.

Сторонники микросервисов, с которыми я разговаривал, хорошо осведомлены об этом 
различии, и я не слышал, чтобы кто-либо из них говорил о внутрипроцессной/удаленной 
прозрачности. Таким образом, они не пытаются делать то, что пытались делать 
распределенные объекты, и, таким образом, не нарушают первый закон. Вместо 
этого они выступали за грубое взаимодействие с документами через HTTP или 
облегченный обмен сообщениями.

Так что по сути нет никакого противоречия между моими взглядами на 
распределенные объекты и сторонниками микросервисов. Несмотря на это 
существенное отсутствие конфликта, есть еще один вопрос, который сейчас 
напрашивается. Микросервисы подразумевают небольшие распределенные единицы, 
которые взаимодействуют через удаленные соединения гораздо чаще, чем монолит. 
Разве это не противоречит духу первого закона, даже если соответствует его 
букве?

Хотя я согласен с тем, что есть веские причины для распределенного проектирования 
многих систем, я все же думаю, что распределённость повышает сложность. Более общий 
API менее удобен, чем детализированный. Вам нужно решить, что вы собираетесь 
делать в случае сбоя удаленных вызовов, а также как это отразится на согласованности 
и доступности. Даже если вы сведете к минимуму удаленные вызовы за счет своего 
протокола, вам все равно придется больше думать о связанных с ними проблемах 
производительности. При проектировании монолита вам приходится беспокоиться о 
распределении обязанностей между модулями, а в распределенной системе вам 
приходится беспокоиться о распределении обязанностей между модулями и факторами
распределённости.

В то время как небольшие микросервисы, безусловно, проще для понимания, я 
беспокоюсь, что это усложняет взаимосвязи между сервисами, где они менее явны 
и, следовательно, труднее понять, когда что-то пойдет не так. Рефакторинг 
становится намного сложнее, когда вам приходится переводить его через удаленные 
границы. Сторонники микросервисов рекламируют уменьшение связанности, которую вы 
получаете от асинхронной связи, но асинхронность — это еще один усилитель 
сложности. [Автоматическое масштабирование](http://paulhammant.com/2011/11/29/cookie-cutter-scaling/) позволяет обрабатывать большие 
объемы трафика без увеличения сложности распределения.

Следовательно, я настороженно отношусь к распределённости и по умолчанию предпочитаю
монолитное проектирование. Учитывая это, почему я потратил много усилий на 
описание микросервисов и поддержку своих коллег, которые их отстаивают? Ответ в 
том, что я знаю, что мои внутренние ощущения не всегда верны. Я не могу отрицать, 
что многие команды использовали микросервисный подход и добились в нем успеха, 
будь то известные публичные проекты, такие как Netflix и (вероятно) Amazon, или 
различные команды, с которыми я общался как внутри, так и вне Thoughtworks.
Я по натуре эмпирик, считающий, что эмпирические данные важнее теории, даже 
если эта теория разработана лучше, чем мое внутреннее чутье.

Не то чтобы я думал, что вопрос еще решен. При предоставлении программного 
обеспечения успех [очень сложно определить](https://martinfowler.com/bliki/WhatIsFailure.html). Хотя такие организации, как Netflix 
и Spotify, трубили о своем прежнем успехе с микросервисами, есть также примеры, 
такие как Etsy или Facebook, которые добились успеха с гораздо более монолитными 
архитектурами. Какой бы успешной команда ни считала себя с микросервисами, 
единственное реальное сравнение было бы контрфактуальным — были бы они лучше с 
монолитом? Подход с использованием микросервисов существует сравнительно 
недавно, поэтому у нас нет достаточных данных об устаревшей микросервисной 
архитектуре десятилетней давности, чтобы сравнить ее с теми старыми монолитами, 
которые нам так не нравятся. И могут быть факторы, которые мы не определили, 
которые означают, что в некоторых случаях монолиты лучше, а в других ситуациях 
предпочтение отдается микросервисам. Учитывая сложность сбора доказательств в 
области разработки программного обеспечения, более вероятно, что не будет 
убедительного решения в пользу того или другого даже по прошествии многих 
лет.

Учитывая эту неопределенность, самое важное, что может сделать такой писатель, 
как я, — это как можно яснее передать те уроки, которые, как мы думаем, мы 
извлекли, даже если они противоречат друг другу. Читатели будут принимать свои 
собственные решения, и наша работа как писателей состоит в том, чтобы убедиться, 
что эти решения являются хорошо обоснованными, какой бы стороны архитектурной 
линии они не придерживались.

***

## Дальнейшее чтение

Моя статья с моим коллегой Джеймсом Льюисом — это наша попытка подготовить 
определение [архитектурного стиля микросервисов](https://martinfowler.com/articles/microservices.html). Я придумал первый закон 
распределенных объектов в своей книге [Шаблоны корпоративных приложений](https://martinfowler.com/articles/microservices.html), он 
появляется в главе 7: «Стратегии распределённости». Эта глава также была 
бесплатно опубликована в Интернете компанией Dr Dobb's под названием 
[Сбившиеся с пути архитектуры](http://www.drdobbs.com/errant-architectures/184414966).

[Заблуждения распределенных вычислений](http://www.rgoarchitects.com/Files/fallacies.pdf) — это классическое утверждение о том, 
почему следует остерегаться любых утверждений о том, что распределённость 
может осуществляться прозрачно (или легко). Заметка Уолдо и др. о [распределенных 
вычислениях](http://scholar.harvard.edu/waldo/publications/note-distributed-computing) была 
прекрасным изложением фундаментальных проблем, связанных с распределенными объектами.