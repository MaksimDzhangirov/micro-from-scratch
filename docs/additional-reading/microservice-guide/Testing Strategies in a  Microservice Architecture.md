# Стратегии тестирования в микросервисной архитектуре

За последние несколько лет в сервисных архитектурах произошел сдвиг в 
сторону более мелких, более сфокусированных «микро» сервисов. У этого подхода 
есть много преимуществ, таких как возможность независимого развертывания, 
масштабирования и обслуживания каждого компонента и параллельная разработка 
несколькими командами. Однако, как только это дополнительное сетевое разделение 
будет введено, стратегии тестирования, которые применялись для работающих монолитных 
приложений, должны быть пересмотрены.

Здесь мы планируем обсудить ряд подходов к управлению дополнительной сложностью 
тестирования нескольких независимо развертываемых компонентов, а также то, 
как сделать так, чтобы тесты и приложение оставались правильными, несмотря на 
наличие нескольких команд, каждая из которых выступает в качестве обслуживающего
персонала для разных сервисов.

18 ноября 2014

Тоби Клемсон (Toby Clemson) — разработчик Thoughtworks, увлеченный созданием 
крупномасштабных распределенных бизнес-систем. Он работал над проектами на 
четырех континентах и в настоящее время живет в Нью-Йорке.

![tdc](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/tdc.jpg)

Моя благодарность [Мартину Фаулеру](https://martinfowler.com/) за его постоянную поддержку в составлении 
этой презентации. Спасибо также [Данило Сато](http://www.dtsato.com/blog/), [Дэну Коффману](https://twitter.com/dc_minutiae), 
[Стивену Лоу](https://twitter.com/StevenALowe), [Крису Форду](https://twitter.com/ctford), 
[Марку Тейлору](https://twitter.com/zoodor), [Прафулу Тодкару](https://twitter.com/todkar), 
[Сэму Ньюману](https://twitter.com/samnewman) и [Маркосу Матосу](https://twitter.com/marcosccm) за 
их отзывы и вклад.

# Содержание

![1](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/1.png)

Сначала некоторые определения...
* [Что такое микросервис?](https://martinfowler.com/articles/microservice-testing/#definition)
* [Анатомия](https://martinfowler.com/articles/microservice-testing/#anatomy-modules): смотрим внутрь микросервиса
* [Архитектура](https://martinfowler.com/articles/microservice-testing/#architecture): осуществляем хореографию сервисов

![2](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/2.png)
...затем стратегии тестирования...
* [Unit](https://martinfowler.com/articles/microservice-testing/#testing-unit-introduction): mock или классическая
* [Интеграционная](https://martinfowler.com/articles/microservice-testing/#testing-integration-introduction): хранилища данных и внешние сервисы
* [Компонентное](https://martinfowler.com/articles/microservice-testing/#testing-component-introduction): в или вне процесса?
* [Контрактное](https://martinfowler.com/articles/microservice-testing/#testing-contract-introduction): обеспечение согласованности между границами
* [Сквозное](https://martinfowler.com/articles/microservice-testing/#testing-end-to-end-introduction): советы и рекомендации

...затем некоторые выводы

* [Возможности](https://martinfowler.com/articles/microservice-testing/#conclusion-options): преимущества микросервисов при тестировании
* [Тестовая пирамида](https://martinfowler.com/articles/microservice-testing/#conclusion-test-pyramid): сколько тестов?
* [Заключение](https://martinfowler.com/articles/microservice-testing/#conclusion-summary): подведение итогов

## Архитектура микросервисов создаёт программное обеспечение в виде набора совместно используемых сервисов.

![3](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/3.png)
Микросервисная архитектура является естественным следствием применения принципа 
единой ответственности на архитектурном уровне. Это приводит к ряду преимуществ 
по сравнению с традиционной монолитной архитектурой, таких как независимая 
возможность развертывания, независимость от языка, платформы и технологии для 
различных компонентов, различные оси масштабируемости и повышенная архитектурная 
гибкость.

**В плане размера нет жестких и чётких правил.** Обычно микросервисы состоят из 
порядка сотен строк, но могут быть десятками или тысячами в зависимости от 
ответственности, которую они инкапсулируют. Хорошее, хотя и неспецифическое, 
эмпирическое правило - они должны быть настолько маленьким, насколько это 
возможно, но настолько большим, насколько это необходимо для представления 
концепции предметной области, с которой они работают. Статья [Насколько большим должен 
быть микросервис?](http://bovon.org/2013/07/09/how-big-should-a-micro-service-be/) 
содержит более подробную информацию.

![2](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/4.png)
Микросервисы часто интегрируются с использованием REST через HTTP. Таким 
образом, концепции предметной области бизнеса моделируются как ресурсы, где один 
или несколько управляются каждым сервисом. В самых зрелых системах RESTful 
ресурсы связаны с помощью элементов управления гипермедиа, так что 
расположение каждого ресурса непрозрачно для потребителей услуг. Для получения 
более подробной информации смотри [модель зрелости Ричардсона](https://martinfowler.com/articles/richardsonMaturityModel.html).

Иногда используются альтернативные механизмы интеграции, такие как упрощенные 
протоколы обмена сообщениями, модели издатель-подписчик или альтернативные 
транспортные протоколы, такие как Protobuf или Thrift.

Каждая микросервис может предоставлять или не предоставлять какую-либо форму 
пользовательского интерфейса.

## Микросервисы обычно можно разделить на аналогичные типы модулей

Часто микросервисы имеют аналогичную внутреннюю структуру, состоящую из 
некоторых или всех отображаемых слоев.

Любая используемая стратегия тестирования должна быть построена так, чтобы охватывать
каждый уровень и межуровневые сервисы, оставаясь при этом легковесными.

![5](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/5.png)

Ресурсы являются преобразователями между протоколом приложения, предоставляемым 
сервисом, и сообщениями в объекты, представляющие предметную область. Как правило, 
они невелики и несут ответственность за проверку работоспособности запроса и 
предоставление ответа, специфичного для протокола, в соответствии с результатом 
бизнес-транзакции.

![6](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/6.png)

Почти вся логика сервиса находится в [модели предметной области](https://martinfowler.com/eaaCatalog/domainModel.html), представляющей 
предметную область. С помощью этих объектов сервисы координируют деятельность нескольких 
предметных областей, в то время как [репозитории](https://martinfowler.com/eaaCatalog/repository.html) воздействуют на наборы сущностей 
предметной области и часто находятся в хранилище.

![7](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/7.png)

Если один сервис использует другой сервис в качестве вспомогательного, необходима 
некоторая логика для связи с внешним сервисом. **[Шлюз](https://martinfowler.com/eaaCatalog/gateway.html) 
инкапсулирует передачу сообщений с удаленным сервисом**, преобразуя запросы и 
ответы от и в объекты предметной области. Скорее всего, он будет использовать клиент, 
который понимает базовый протокол для обработки цикла запрос-ответ.

![8](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/8.png)
За исключением самых простых случаев или когда сервис действует как агрегатор 
ресурсов, принадлежащих другим сервисам, микросервис должен иметь **возможность
сохранять объекты из предметной области между запросами**. Обычно это достигается с 
помощью ORM или более легких [средств сопоставления данных](https://martinfowler.com/eaaCatalog/dataMapper.html) в зависимости от сложности 
требований к сохранению.

Часто эта логика инкапсулируется в набор выделенных объектов, используемых 
репозиториями предметной области.

## Микросервисы взаимодействуют друг с другом через сеть... и используют «внешние» хранилища данных

Микросервисы обрабатывают запросы, передавая сообщения между каждым из 
соответствующих модулей для формирования ответа. Конкретный запрос может 
потребовать взаимодействия с сервисами, шлюзами или репозиториями, поэтому 
модулями между собой слабо связанные.

![9](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/9.png)

Автоматизированные тесты должны покрывать каждое из этих сообщений с 
максимально возможной степенью детализации. Таким образом, каждый тест обеспечивает 
сфокусированный и быстрый цикл обратной связи.

![10](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/10.png)

Ресурс получает запрос и после проверки передает в предметную область, чтобы 
начать обработку запроса.

![11](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/11.png)

Если для выполнения бизнес-транзакции необходимо скоординировать множество 
модулей, ресурс делегирует это сервису. В противном случае он взаимодействует 
напрямую с соответствующим модулем.

![12](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/12.png)

Связи с внешними сервисами требуют особого внимания, поскольку они пересекают 
границы сети. Система должна быть устойчива к отказам удаленных компонентов. 
Шлюзы содержат логику для обработки таких случаев ошибок.

Как правило, связь с внешними сервисами более обобщенная, чем аналогичная связь 
между процессами, чтобы предотвратить передачу слишком большого числа сообщений 
и задержку API.

![13](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/13.png)

Точно так же связь с внешними хранилищами данных имеет различные особенности 
проектирования. Хотя сервис часто более логически связана со своим хранилищем 
данных, чем с внешней сервисом, хранилище данных по-прежнему существует за 
границей сети, вызывая задержку и риск простоя.

![14](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/14.png)

Наличие сетевого разбиения влияет на используемый стиль тестирования. Тесты 
этих модулей могут выполняться дольше и могут завершиться неудачей по причинам, 
не зависящим от команды.

## Несколько сервисов работают вместе как система... ...чтобы предоставить важный для бизнеса функционал

![15](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/15.png)

Как правило, команда выступает в качестве обслуживающего персонала одного или
нескольких сервисов. Эти сервисы обмениваются сообщениями для обработки более 
крупных бизнес-запросов. Что касается формата обмена, в настоящее время 
наиболее популярен JSON, хотя существует ряд альтернатив, наиболее 
распространенным из которых является XML.

В некоторых случаях асинхронный механизм связи издатель-подписчик подходит для 
сценария использования лучше, чем синхронный механизм точка-точка. Формат 
синдикации Atom становится все более популярным как легкое средство реализации 
шаблона издатель-подписчик между микросервисами.

Поскольку бизнес-запрос охватывает несколько компонентов, разделенных сетью,
важно учитывать возможные случаи отказа в системе. Такие методы, как тайм-ауты, 
[circuit breakers](https://martinfowler.com/bliki/CircuitBreaker.html) и bulkheads, могут помочь поддерживать работоспособность 
системы в целом, несмотря на отказ компонентов.

![16](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/16.png)

В более крупных системах часто существует несколько команд, каждая из которых 
отвечает за разные [ограниченные контексты](https://martinfowler.com/bliki/BoundedContext.html).

Принципы тестирования внешних сервисов могут отличаться от задач тестирования 
сервисов, находящихся под контролем вашей группы, поскольку предоставляют 
меньше гарантий в отношении интерфейса и доступности внешних сервисов других 
команд.

## Unit тестирование

> Unit тест проверяет наименьшую часть тестируемого программного обеспечения в 
> приложении, чтобы определить, ведет ли оно себя так, как ожидалось. ➊➋➌

![17](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/17.png)

Размер тестируемого модуля строго не определен, однако unit тесты обычно 
пишутся на уровне класса или вокруг небольшой группы связанных классов. Чем 
меньше тестируемый модуль, тем проще выразить поведение с помощью unit 
теста, поскольку сложность ветвления в модуле ниже.

Часто трудности с написанием unit теста могут выявить ситуацию, когда модуль следует 
разбить на независимые более согласованные части и протестировать по 
отдельности. Таким образом, **unit тестирование является не только полезной 
стратегией тестирования, но и мощным инструментом проектирования**, особенно в 
сочетании с разработкой через тестирование.

При unit тестировании вы видите важное различие, основанное на том, 
изолирован ли тестируемый модуль от его партнеров.

![18](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/18.png)

[Социальное unit тестирование](https://leanpub.com/wewut) фокусируется на тестировании поведения 
модулей путем наблюдения за изменениями их состояния. При этом тестируемое 
устройство рассматривается как черный ящик, полностью тестируемый через 
его интерфейс.

![19](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/19.png)

[Одиночное unit тестирование](https://leanpub.com/wewut) рассматривает взаимодействия и совместную работу 
между объектом и его зависимостями, которые заменяются тестовыми двойниками.

Эти стили не конкурируют друг с другом и часто используются в одной кодовой 
базе для решения разных задач тестирования.

## Оба стиля unit тестирования играют важную роль внутри микросервиса

![20](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/20.png)

Сервисы обычно представляют собой хорошо описанную предметную область, окруженную
преобразующим и координирующим кодом.

![21](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/21.png)

Логика предметной области часто содержит сложные вычисления и набор переходов
между состояниями. Поскольку эти типы логики в значительной степени основаны на 
состоянии, попытка изолировать модули не имеет смысла. Это означает, что, 
насколько это возможно, для всех вспомогательных элементов тестируемого модуля должны 
использоваться реальные объекты предметной области.

![22](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/22.png)

Если существует преобразующий код сложно одновременно изолировать тестируемый 
модуль от внешних модулей и тестировать изменения состояния. Таким образом, 
использование тестовых двойников более эффективно.

Целью модульных тестов на этом уровне является проверка любой логики, 
используемой для создания запросов или сопоставления ответов от внешних 
зависимостей, а не интегрированная проверка взаимодействия. Таким образом, 
использование тестовых двойников для вспомогательных объектов обеспечивает 
надежный и воспроизводимый способ управления циклом запрос-ответ.

Unit тесты на этом уровне обеспечивают более быструю обратную связь, чем 
интеграционные тесты, и могут вызывать условия при которых происходят ошибки, 
заставляя двойников реагировать так же, как внешняя зависимость в исключительных 
ситуациях.

![23](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/23.png)

Координирующая логика больше заботится о сообщениях, передаваемых между 
модулями, чем о любой сложной логике внутри этих модулей. Использование 
тестовых двойников позволяет проверять детали переданных сообщений и применять 
заглушки вместо ответов, так что поток сообщений внутри модуля может быть 
определен в тесте.

Если часть координационной логики требует слишком много двойников, обычно это
означает, что какую-то концепцию следует извлечь и протестировать изолированно.

По мере уменьшения размера сервиса увеличивается соотношение логики 
преобразования и координации к сложной логике предметной области. Так некоторые 
сервисы будут содержать полностью логику преобразования и координации, например 
адаптеры для различных технологий или агрегаторы по сравнению с другими сервисами.

В таких случаях комплексное модульное тестирование может не окупиться. Другие 
уровни тестирования, такие как тестирование компонентов, могут быть более полезными.

Целью unit тестов и тестирования в целом является ограничение поведения 
тестируемого модуля. Неприятный побочный эффект заключается в том, что иногда 
тесты также ограничивают реализацию. Это часто проявляется в чрезмерном 
употреблении имитационных подходов.

Важно постоянно подвергать сомнению ценность, которую обеспечивает unit тест, 
по сравнению с затратами на его обслуживание или тем, как он ограничивает вашу 
реализацию. Делая это, можно сохранить набор тестов небольшим, сфокусированным 
и высококачественным.

## Само по себе unit тестирование не дает гарантий поведения системы

![24](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/24.png)

На данный момент у нас есть хорошее покрытие тестами каждого из основных 
модулей системы в отдельности. Однако эти модули не покрываются, когда они 
работают вместе, чтобы сформировать полный сервис, или взаимодействия, которые 
они имеют с удаленными зависимостями.

Чтобы убедиться, что каждый модуль правильно взаимодействует с соседними, 
требуется более общее тестирование.

## Интеграционное тестирование

> Интеграционный тест проверяет каналы связи и взаимодействия между компонентами 
> для обнаружения дефектов интерфейса. ➊➋➌

![25](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/25.png)
Интеграционные тесты объединяют модули вместе и тестируют их как подсистему, 
чтобы убедиться, что они взаимодействуют должным образом для достижения более 
крупного поведения. Они проверяют каналы связи через подсистему, чтобы 
проверить любые неверные предположения каждого модуля о том, как 
взаимодействовать со своими одноранговыми узлами.

Это отличается от unit тестов, где даже при использовании реальных соседних элементов 
цель состоит в том, чтобы тщательно протестировать поведение тестируемого 
модуля, а не всей подсистемы.

![26](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/26.png)
Хотя тесты, интегрирующие компоненты или модули, могут быть написаны с любой 
степенью детализации, в микросервисных архитектурах они обычно используются для 
проверки взаимодействия между слоями интеграционного кода и внешними 
компонентами, с которыми они интегрируются.

Примерами внешних компонентов, для которых могут быть полезны такие 
интеграционные тесты, могут быть другие микросервисы, хранилища данных и кэши.

## Интеграции с хранилищами данных и внешними компонентами... ...воспользуйтесь быстрой обратной связью интеграционных тестов

![27](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/27.png)

При написании автоматизированных тестов модулей, которые взаимодействуют с 
внешними компонентами, цель состоит в том, чтобы убедиться, что модуль может 
достаточно взаимодействовать, а не в приемочном тестировании внешнего 
компонента. Таким образом, тесты этого типа должны быть направлены на то, чтобы 
охватить основные успешные и ошибочные случаи через модуль интеграции.

![28](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/28.png)

**Интеграционные тесты шлюза** позволяют устранять любые ошибки на уровне 
протокола, такие как отсутствующие заголовки HTTP, неправильная обработка SSL 
или несоответствие тела запроса/ответа с максимально возможной детализацией 
тестирования.

Любая обработка ошибок в особых случаях также должна быть протестирована, чтобы 
гарантировать, что используемый клиент сервиса и протокола будет реагировать 
должным образом в исключительных обстоятельствах.

Иногда бывает трудно вызвать ненормальное поведение, такое как тайм-ауты или 
медленные ответы от внешнего компонента. В этом случае может быть полезно 
использовать заглушку внешнего компонента в качестве тестовой системы, которую 
можно настроить на сбой заранее определенным образом.

Управление состоянием может быть затруднено при тестировании внешних 
компонентов, поскольку тесты будут основываться на наличии определенных 
данных. Один из способов смягчить эту проблему — договориться о фиксированном 
наборе репрезентативных, но безвредных данных, которые гарантированно будут 
доступны в любой среде.

![29](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/29.png)

Интеграционные тесты хранилищ обеспечивают уверенность в том, что схема, 
предполагаемая кодом, соответствует схеме, доступной в хранилище данных.

В случае использования ORM эти тесты также дают уверенность в том, что любые 
сопоставления, настроенные в инструменте, совместимы с возвращаемыми наборами 
результатов.

Современные ORM очень сложны с точки зрения кэширования и очищаются только при 
необходимости. Важно структурировать тесты таким образом, чтобы транзакции 
осуществлялись между предварительными условиями, действиями и утверждениями, чтобы 
гарантировать, что данные проходят полный цикл.

Поскольку большинство хранилищ данных расположены где-то в сети, они также 
подвержены тайм-аутам и сбоям сети. Интеграционные тесты должны попытаться 
проверить, корректно ли модули интеграции обрабатывают эти сбои.

Тесты, написанные таким образом, обеспечивают быструю обратную связь при рефакторинге или 
расширении логики, содержащейся в модулях интеграции. Однако они могут отказывать по 
разным причинам — если логика в модуле интеграции устаревает или 
если внешний компонент становится недоступным или нарушает его контракт.

Чтобы смягчить эту проблему, напишите лишь несколько интеграционных тестов, 
чтобы обеспечить быструю обратную связь, когда это необходимо, и обеспечьте 
дополнительное покрытие модульными тестами и [контрактными тестами](https://martinfowler.com/articles/microservice-testing/#testing-contract-introduction) для 
всесторонней проверки каждой стороны границы интеграции. Также может иметь 
смысл разделить интеграционные тесты в конвейере сборки CI, чтобы внешние сбои 
не блокировали разработку.

## Без более общих тестов микросервиса... мы не уверены, что удовлетворены бизнес-требования

![30](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/30.png)

Благодаря unit и интеграционному тестированию мы можем быть уверены в 
правильности логики, содержащейся в отдельных модулях, составляющих 
микросервис.

Однако без более общего набора тестов мы не можем быть уверены, что микросервис 
работает вместе как единое целое для удовлетворения бизнес-требований.

Хотя этого можно достичь с помощью полностью интегрированных [сквозных тестов](https://martinfowler.com/articles/microservice-testing/#testing-end-to-end-introduction), 
более точную обратную связь и меньшее время выполнения тестов можно получить 
путем тестирования микросервиса, изолированного от его внешних зависимостей.

## Компонентное тестирование

> Компонентный тест ограничивает область действия тестируемого программного 
> обеспечения частью тестируемой системы, манипулируя системой через интерфейсы 
> внутреннего кода и используя тестовые двойники для изоляции тестируемого кода 
> от других компонентов. ➊

![31](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/31.png)

Компонент — это любая хорошо инкапсулированная, согласованная и независимо 
заменяемая часть более крупной системы.

Тестирование таких компонентов по отдельности дает ряд преимуществ. Ограничив 
интересующую область одним компонентом, можно тщательно провести приемочное 
тестирование поведения, заключенное в этом компоненте, при этом поддерживая 
тесты, которые выполняются быстрее, чем эквивалентные более широкого спектра.

Изоляция компонента от его внешних узлов с помощью тестовых двойников позволяет 
избежать любого сложного поведения, которое они могут иметь. Это также помогает 
обеспечить контролируемую среду тестирования для компонента, запуская любые 
возможные случаи ошибок повторяемым образом.

![32](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/32.png)

В микросервисной архитектуре компоненты сами по себе являются сервисами.
При написании тестов с такой степенью детализации контракт API управляется 
тестами с точки зрения потребителя. Изоляция сервиса достигается заменой внешних 
элементов тестовыми двойниками и использованием внутренних конечных точек 
API для проверки или настройки сервиса.

Реализация таких тестов включает ряд вариантов. Должен ли тест выполняться в 
том же процессе, что и сервис, или вне процесса по сети? Должны ли тестовые 
двойники находиться внутри сервиса или снаружи, по сети? Следует ли использовать 
реальное хранилище данных или заменить его альтернативным хранилищем в памяти? 
В следующем разделе это обсуждается подробнее.

## Тестирование компонентов в процессе позволяет проводить всестороннее тестирование... ...с минимальным количеством изменяющихся частей

![33](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/33.png)

Путем создания полного экземпляра микросервиса в памяти с использованием 
тестовых двойников и хранилищ данных в памяти можно писать тесты компонентов, 
которые вообще не используют сеть.

Это может привести к сокращению времени выполнения тестов и минимизации 
количества изменяющихся частей, что снижает сложность сборки.

Однако это также означает, что тестируемый артефакт должен быть изменен для 
целей тестирования, чтобы он мог запускаться в «тестовом» режиме. Фреймворки 
внедрения зависимостей могут помочь в достижении этого, подставляя разные элементы 
в приложение в зависимости от конфигурации, предоставленной во время запуска.

![34](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/34.png)

Тесты взаимодействуют с микросервисом через внутренний интерфейс, позволяющий 
отправлять запросы и получать ответы. Часто для этого используется [специальная 
оболочка](http://en.wikipedia.org/wiki/Shim_(computing)), хотя существует ряд 
готовых библиотек, таких как [inprotester](https://github.com/aharin/inproctester) для 
микросервисов на основе JVM и [plasma](https://github.com/jennifersmith/plasma) для микросервисов на основе .NET.

Таким образом, внутрипроцессное тестирование компонентов может максимально 
приблизиться к выполнению реальных HTTP-запросов к сервису без дополнительных 
накладных расходов, связанных с реальными сетевыми взаимодействиями.

![35](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/35.png)

Чтобы изолировать микросервис от внешних сервисов, шлюзы можно настроить на 
использование тестовых двойников вместо реальных клиентов на уровне протокола.
Используя внутренние ресурсы, эти тестовые двойники можно запрограммировать на 
возврат предопределенных ответов при совпадении определенных запросов.

Эти тестовые двойники также можно использовать для имитации сценариев работы 
компонента в случае возникновения ошибок, например, когда внешние элементы не в сети или 
реагируют медленно или с искаженными ответами. Это позволяет проверять состояния 
ошибок контролируемым и воспроизводимым образом.

![36](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/36.png)

Замена внешнего хранилища данных [реализацией в памяти](https://martinfowler.com/bliki/InMemoryTestDatabase.html) может значительно повысить 
производительность тестирования. Несмотря на то, что это исключает реальное 
хранилище данных из границ теста, любые [интеграционные тесты](https://martinfowler.com/articles/microservice-testing/#testing-integration-introduction) хранилищ 
обеспечат достаточное покрытие.

В некоторых случаях используемый механизм сохранения достаточно прост, чтобы 
можно было использовать упрощенную пользовательскую реализацию. Кроме того, 
некоторые хранилища данных, такие как [Cassandra](http://cassandra.apache.org/) и [Elasticsearch](http://www.elasticsearch.org/), предоставляют 
встроенные реализации. Также доступны инструменты, которые эмулируют внешние 
хранилища данных в памяти, такие как ядро [базы данных H2](http://www.h2database.com/html/main.html).

![37](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/37.png)

Несмотря на то, что можно настраивать тестовые двойники и настраивать данные 
непосредственно при написании внутрипроцессных приемочных тестов, маршрутизация 
всех запросов через специализированные внутренние ресурсы позволяет тестировать 
сервис как нечто вроде черного ящика. Это позволяет вносить изменения в 
технологию хранения данных или взаимодействие с внешними сервисами, не влияя на
набор тестов компонентов.

## Внутренние ресурсы полезны не только для тестирования...

Хотя это может показаться странным, **открытие доступа к внутреннему управлению 
как к ресурсам может оказаться полезным в ряде случаев, помимо тестирования, 
например, мониторинга, обслуживания и отладки**. Единообразие RESTful API 
означает, что уже существует множество инструментов для взаимодействия с 
такими ресурсами, которые могут помочь снизить общую сложность работы.

Типы внутренних ресурсов, которые обычно предоставляются, включают логи, 
параметры функций, команды базы данных и системные метрики. Многие микросервисы 
также включают ресурсы проверки работоспособности, которые предоставляют 
информацию о работоспособности сервиса и её зависимостях, времени выполнения 
ключевых транзакций и сведениях о параметрах конфигурации. Простой ресурс ping 
также может быть полезен для балансировки нагрузки.

Поскольку эти ресурсы являются более привилегированными с точки зрения управления, 
который они имеют, или информации, которую они раскрывают, они часто требуют 
собственной аутентификации или блокировки на сетевом уровне. За счет добавления пространства 
имен в те части API, которые образуют внутренние элементы управления, с использованием 
соглашений об именах URL-адресов или путем предоставления доступа к этим ресурсам 
через другой сетевой порт доступ может быть ограничен на уровне брандмауэра.

![38](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/38.png)

## Внепроцессные тесты компонентов проверяют полностью развернутый элемент... ...где сложность заглушки ограничивается тестом

![39](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/39.png)

Выполнение тестов компонентов для микросервиса, развернутого как отдельный процесс, 
позволяет использовать больше слоёв и точек интеграции. Поскольку во всех 
взаимодействиях используются настоящие сетевые вызовы, элемент развертывания 
может оставаться неизменным без какой-либо специальной логики тестирования.

При таком подходе сложность переносится на систему тестирования, которая 
отвечает за запуск и остановку внешних заглушек, а также за координацию сетевых 
портов и конфигурации.

В результате сетевых взаимодействий и использования реального хранилища данных 
время выполнения теста, вероятно, увеличится. Однако если микросервис имеет 
сложную логику интеграции, сохранения или запуска, внепроцессный подход может 
быть более подходящим.

![40](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/40.png)

Поскольку микросервис прослушивает порт в другом процессе, в дополнение к 
проверке поведения внепроцессные тесты компонентов проверяют, что микросервис 
имеет правильную сетевую конфигурацию и способна обрабатывать сетевые запросы.

![41](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/41.png)

Точно так же модули клиента и хранилища выполняются во время интеграции с 
внешними зависимостями в отдельных процессах. Обвязка тестов настраивает 
микросервис во время запуска, чтобы убедиться, что она указывает на правильные 
URL-адреса для тестовых зависимостей.

![42](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/42.png)

Внешние сервисные заглушки доступны в нескольких различных вариантах: некоторые 
из них динамически программируются через API, некоторые используют данные 
фикстуры, созданные вручную, а некоторые используют механизм записи-воспроизведения, 
фиксирующий запросы и ответы на реальный внешний сервис.

Примеры инструментов включают [moco](https://github.com/dreamhead/moco), [stubby4j](https://github.com/azagniotov/stubby4j) 
и [mountebank](https://github.com/bbyars/mountebank), которые поддерживают 
как динамические заглушки, так и заглушки на основе фикстур, и [vcr](https://github.com/vcr/vcr), который 
реализует заглушки в стиле записи-воспроизведения.

Если у внешнего сервиса много зависимостей, может оказаться целесообразным создать 
специальную заглушку для этого сервиса, чтобы потребителям не приходилось самим 
управлять заглушкой.

## Комбинация стратегий тестирования приводит к... ...высокому тестовому покрытию

![43](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/43.png)

Комбинируя unit, интеграционное и компонентное тестирование, мы можем добиться 
высокого покрытия модулей, составляющих микросервис, и можем быть уверены, что 
микросервис корректно реализует требуемую бизнес-логику.

Тем не менее, во всех случаях использования, кроме самых простых, это не имеет ценности для 
бизнеса, если множество микросервисов не работают вместе для удовлетворения более 
крупных бизнес-процессов. В этой схеме тестирования по-прежнему нет тестов, 
гарантирующих, что внешние зависимости соответствуют ожидаемому от них 
контракту, или что наша коллекция микросервисов правильно взаимодействует для 
обеспечения сквозных бизнес-потоков.

В этом помогает [контрактное тестирование](https://martinfowler.com/articles/microservice-testing/#testing-contract-introduction) внешних зависимостей и более 
крупномасштабное [сквозное тестирование](https://martinfowler.com/articles/microservice-testing/#testing-end-to-end-introduction) всей системы.

## Контрактное тестирование

> Интеграционные тесты контракта — это тест на границе внешнего сервиса, 
> проверяющий, соответствует ли он контракту, ожидаемому потребляющим сервисом. ➊➋

![44](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/44.png)

Всякий раз, когда какой-либо потребитель подключается к интерфейсу компонента, 
чтобы использовать его поведение, между ними формируется контракт. Этот контракт 
состоит из ожиданий структур входных и выходных данных, побочных эффектов и 
характеристик производительности и параллелизма.

Каждый потребитель компонента формирует отдельный контракт на основе своих 
требований. Если компонент подлежит изменению с течением времени, важно, чтобы 
контракты каждого из потребителей продолжали выполняться.

Интеграционные тесты контрактов предоставляют механизм для явной проверки того, 
что компонент соответствует контракту.

![45](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/45.png)

Когда задействованными компонентами являются микросервисы, интерфейс представляет 
собой общедоступный API, предоставляемый каждым сервисом. Специалисты по 
сопровождению каждого сервиса-потребителя пишут независимый набор тестов, который 
проверяет только используемые аспекты сервиса-создателя.

Эти тесты не являются [тестами компонентов](https://martinfowler.com/articles/microservice-testing/#testing-component-introduction). 
Они не проверяют глубоко поведение сервиса, а лишь то, что входные и выходные 
данные вызовов сервисов содержат необходимые атрибуты, а задержка ответа и 
пропускная способность находятся в допустимых пределах.

В идеале наборы контрактных тестов, написанные каждой командой-потребителем, 
упакованы и могут запускаться в конвейерах сборки для создающих сервисов. 
Таким образом, сопровождающие сервисы-создатели знают, как их изменения 
повлияют на их потребителей.

## Сумма всех тестов потребительских контрактов... ...определяет общий контракт сервиса

![46](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/46.png)

Хотя контрактные тесты вселяют уверенность потребителям внешних сервисов, они 
еще более ценны для тех, кто занимается сопровождением этих сервисов. Получая 
наборы контрактных тестов от всех потребителей сервиса, можно безопасно вносить 
изменения в этот сервис, зная, что потребители не будут затронуты.

![47](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/47.png)

Рассмотрим сервис, который предоставляет ресурс с тремя полями, идентификатором, 
именем и возрастом. Этот сервис используется тремя разными потребителями, 
каждому из которых нужны разные части ресурса.

![48](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/48.png)

Потребитель A использует только поля "идентификатор" и "имя". Таким образом, 
соответствующий набор тестов контракта предполагает, что ответ ресурса содержит 
эти поля. Он не делает никаких предположений относительно поля "возраст".

![49](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/49.png)

Потребитель B использует поля "идентификатор" и "возраст", поэтому тесты 
контракта предполагают, что они присутствуют, но не делают предположений о поле 
"имя".

![50](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/50.png)

Потребителю C требуются все три поля, и у него есть набор тестов контракта, 
который предполагает, что все они присутствуют.

![47](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/47.png)

Если новый потребитель начинает использовать API, но ему требуется и имя, и 
фамилия, сопровождающие могут принять решение отказаться от поля имени и ввести 
другое поле, содержащее составной объект из имени и фамилии.

Чтобы увидеть, что потребуется для удаления старого поля "имя", команда 
сопровождения может удалить его из ответа и посмотреть какие тесты контракта не
пройдут. В этом случае они увидят, что потребители A и C должны быть уведомлены 
об устаревании. После того как потребители A и C перейдут на использование 
нового поля, устаревшее поле можно удалить.

Чтобы это было эффективно, как создатели, так и потребители должны следовать 
[закону Постела](https://en.wikipedia.org/wiki/Robustness_principle) при сериализации и десериализации сообщений, игнорируя любые 
поля, которые не важны для них.

Этот подход является примером [параллельного изменения](https://martinfowler.com/bliki/ParallelChange.html), при котором API можно 
изменять в течение определенного периода времени, не нарушая договор с 
какими-либо потребителями.

![46](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/46.png)

Наборы контрактных тестов также полезны при определении нового сервиса. 
Потребители могут управлять дизайном API, создавая набор тестов, которые 
выражают то, что им нужно от сервиса.

Эти контракты, ориентированные на потребителя, являются предметом обсуждения с 
командой, ответственной за создание сервиса, а также являются автоматическими 
тестами, которые указывают на готовность API.

Существует ряд инструментов, помогающих в написании контрактных тестов, такие 
как [Pact](https://github.com/realestate-com-au/pact), [Pacto](https://github.com/thoughtworks/pacto) и 
[Janus](https://github.com/gga/janus).

## Сквозное тестирование

> Сквозное тестирование проверяет, соответствует ли система внешним требованиям 
> и достигает поставленных целей, тестируя всю систему от начала до конца. ➊➋

![51](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/51.png)

В отличие от других типов тестов цель сквозных тестов состоит в том, чтобы 
убедиться, что система в целом соответствует бизнес-целям, независимо от 
используемой архитектуры компонентов.

Чтобы достичь этого, система рассматривается как черный ящик, и тесты максимально 
используют полностью развернутую систему, манипулируя ею через общедоступные 
интерфейсы, такие как графические интерфейсы пользователя и API-интерфейсы сервисов.

Поскольку сквозные тесты в большей степени ориентированы на бизнес, они часто 
используют удобочитаемые для бизнеса предметно-ориентированный язык, который 
выражают тестовые примеры на языке предметной области.

![52](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/52.png)

Поскольку микросервисная архитектура включает в себя больше взаимодействующих частей 
для одного и того же поведения, сквозные тесты обеспечивают ценность, добавляя 
покрытие пробелов между сервисами. Это дает дополнительную уверенность в 
правильности передачи сообщений между сервисов, а также гарантирует правильную 
настройку любой дополнительной сетевой инфраструктуры, такой как брандмауэры, 
прокси-серверы или балансировщики нагрузки.

Сквозные тесты также позволяют архитектуре микросервисов развиваться с течением 
времени. По мере того, как о проблемной области становится все больше известно, 
сервисы, скорее всего, будут разделены или объединены, а сквозные тесты дают 
уверенность в том, что бизнес-функции, предоставляемые системой, останутся 
нетронутыми во время таких крупномасштабных архитектурных рефакторингов.

## Тестовая граница для сквозных тестов... ...намного больше, чем для других типов тестов

![53](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/53.png)

Поскольку цель состоит в том, чтобы проверить поведение полностью интегрированной 
системы, сквозные тесты взаимодействуют с максимально возможной степенью детализации.

Если система требует прямого манипулирования пользователем, это взаимодействие 
может осуществляться через графические интерфейсы, предоставляемые одним или 
несколькими микросервисами. В этом случае такие инструменты, как [Selenium 
WebDriver](http://docs.seleniumhq.org/projects/webdriver/), могут помочь заставить графический интерфейс запускать определенные 
варианты использования в системе.

Для безголовых систем сквозные тесты напрямую манипулируют микросервисами через 
их общедоступные API с использованием HTTP-клиента.

Таким образом, правильность системы устанавливается путем наблюдения за 
изменениями состояния или событиями на периметре, образованном тестовой 
границей.

![54](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/54.png)

Хотя некоторые системы достаточно малы, чтобы одной команде принадлежали все 
составные компоненты, во многих случаях системы становятся зависимыми от одного 
или нескольких управляемых извне микросервисов.

Обычно эти внешние сервисы включаются в границы сквозного тестирования. Однако 
в редких случаях вы можете их исключить.

Если внешним сервисом управляет третья сторона, может оказаться невозможным 
написать сквозные тесты повторяемым образом и без побочных эффектов. Точно так 
же некоторые сервисы могут страдать от проблем с надежностью, которые приводят 
к сбою сквозных тестов по причинам, не зависящим от команды.

В таких случаях может быть полезно заглушить внешние сервисы, потеряв некоторую 
сквозную уверенность в работе системы, но добившись стабильности в наборе тестов.

## Написание и поддержка сквозных тестов может быть очень сложной задачей

Поскольку сквозные тесты включают в себя гораздо больше взаимодействующих частей, чем 
другие стратегии, обсуждавшиеся до сих пор, у них, в свою очередь, больше 
причин для неудачи. Сквозные тесты также могут учитывать асинхронность в 
системе, будь то в графическом интерфейсе или из-за асинхронных внутренних 
процессов между сервисами. Эти факторы могут привести к нестабильности, 
чрезмерному времени выполнения теста и дополнительным затратам на обслуживание 
набора тестов.

Следующие рекомендации могут помочь справиться с дополнительной сложностью 
сквозных тестов:

1) Напишите как можно меньше сквозных тестов:

> Учитывая, что высокий уровень достоверности может быть достигнут за счет более 
> низких уровней тестирования, роль сквозных тестов заключается в том, чтобы 
> убедиться, что все взаимосвязано и между микросервисами нет разногласий на 
> высоком уровне.

> Таким образом, всестороннее тестирование бизнес-требований на этом уровне 
> расточительно, особенно с учетом затрат на сквозные тесты во времени и 
> обслуживании.

> Одна из стратегий, которая хорошо работает сохраненяя небольшой набор 
> сквозных тестов, заключается в применении **бюджета времени**, количества 
> времени, в течение которого команда будет не против ждать пока выполнится набор
> тестов. По мере роста пакета, если время выполнения начинает превышать бюджет 
> времени, наименее ценные тесты удаляются, чтобы уложиться в отведенное время. 
> Бюджет времени должен быть порядка минут, а не часов.

2) Сосредоточьтесь на пользователях и последовательности действий пользователя

> Чтобы убедиться, что все тесты в комплексном пакете являются ценными, 
> смоделируйте их с точки зрения пользователей системы и последовательности 
> действий, которые эти пользователи совершают в системе. Это обеспечивает 
> уверенность в тех частях системы, которые пользователи ценят больше всего, и 
> оставляет все остальное для других типов тестирования.

> Такие инструменты, как [Gauge](http://getgauge.io/) и [Concordion](http://concordion.org/), существуют, чтобы помочь выразить
> последовательности действий с помощью бизнес-читаемых предметно-ориентированных 
> языков.

3) Правильно выберите границы теста

> Если конкретный внешний сервис или графический интерфейс являются основной 
> причиной нестабильности в наборе тестов, это может помочь переопределить 
> границы теста, чтобы исключить этот компонент. В этом случае полное сквозное 
> покрытие жертвует надежностью набора тестов. Это приемлемо до тех пор, пока 
> другие формы тестирования проверяют ненадежный компонент с использованием 
> других средств.

4) Используйте принцип инфраструктура как код для повторяемости

> [Snowflake окружения](https://martinfowler.com/bliki/SnowflakeServer.html) также могут быть источником недетерминированного поведения, 
> особенно если они используются не только для сквозного тестирования.

> Если вы воспользовались принципом инфраструктура как кодом, который может 
> значительно помочь в управлении дополнительной сложностью развертывания 
> микросервисной архитектуры, то сможете создавать окружения на лету воспроизводимым 
> образом.

> Создавая новую среду для каждого выполнения сквозного набора тестов, можно 
> повысить надежность, а также проверить логику развертывания.

5) Сделайте тесты независимыми от данных

> Распространенным источником трудностей при сквозном тестировании является 
> управление данными. Использование уже существующих данных может привести к 
> сбою, поскольку данные изменяются и накапливаются в окружении. Я называю это 
> ложными сбоями, поскольку сбой не является признаком ошибки в программном 
> обеспечении.

> Автоматизированное управление данными, на которые опираются сквозные тесты, 
> снижает вероятность ложных сбоев. Если сервисы поддерживают создание 
> принадлежащих им сущностей через общедоступные или внутренние API, сквозные 
> тесты могут определить их мир перед выполнением. Для тех сервисов, которые 
> не допускают внешнего создания, готовые данные можно импортировать на уровне 
> базы данных.

Из-за трудностей, присущих написанию тестов в этом стиле, некоторые команды 
предпочитают полностью избегать сквозного тестирования в пользу тщательного 
производственного мониторинга и тестирования непосредственно в продакшен 
среде.

**Искусственные транзакции** — поддельные пользователи, осуществляющие настоящие 
транзакции в продакшен системе, — могут дополнять типичные методы мониторинга, 
обеспечивая более полное представление о состоянии продакшен системы. Кроме 
того, оповещение о выходе ключевых бизнес-показателей за пределы допустимых 
норм может помочь быстро выявить продакшен проблемы.

## Архитектуры микросервисов предоставляют больше возможностей в смысле где и как проводить тестирование

![55](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/55.png)

Разбивая систему на небольшие четко определенные сервисы, выявляются 
дополнительные границы, которые ранее были скрыты. Эти границы обеспечивают 
возможности и гибкость с точки зрения типа и уровня тестирования, которое можно 
использовать.

В некоторых случаях микросервис может инкапсулировать центральный 
бизнес-процесс со сложными требованиями. Критичность этого процесса может 
потребовать очень всестороннего тестирования службы, такого как полный спектр 
стратегий тестирования, обсуждаемых здесь. В других случаях микросервис может 
быть экспериментальным, менее важным с точки зрения бизнеса или иметь короткий 
срок службы. Требуемый уровень тестирования может быть ниже, так что только 
пара стратегий имеет смысл.

Хотя этот процесс принятия решений по-прежнему возможен в монолитной 
архитектуре, добавление четких, четко определенных границ облегчает просмотр 
компонентов вашей системы и работу с ними изолированно.

## Тестовая пирамида помогает нам поддерживать баланс между различными видами тестирования

![56](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/56.png)

В общем, чем более общим является тест, тем более хрупким он становится, 
требует много времени для выполнения, его труднее писать и поддерживать. Эти 
дополнительные расходы связаны с тем фактом, что в таких тестах, естественно, 
задействовано больше взаимодействующих частей, чем в более детализированных, 
сфокусированных.

Понятие [тестовой пирамиды](https://martinfowler.com/bliki/TestPyramid.html) — это 
простой способ представить относительное количество тестов, которые должны быть 
написаны для каждой степени детализации. При продвижении по уровням пирамиды 
часть системы, которую охватывает тест, увеличивается, а количество тестов, 
необходимых для написания, уменьшается.

На вершине пирамиды находится исследовательское тестирование, когда
система исследуется вручную способами, которые не рассматривались как часть 
тестов по сценарию. Исследовательское тестирование позволяет команде узнать о 
системе, а также обучать и улучшать свои автоматизированные тесты.

Следуя рекомендациям тестовой пирамиды, мы можем избежать снижения ценности 
тестов из-за большого набора тестов, которые дорого поддерживать и выполнять.

## Заключение...

![unit](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/unit.png)

* Unit тесты: тестируйте самые маленькие части тестируемого программного 
  обеспечения в приложении, чтобы определить, ведут ли они себя так, как 
  ожидалось.

![integration](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/integration.png)

* Интеграционные тесты: проверьте способы коммуникации и взаимодействия между 
  компонентами для обнаружения дефектов интерфейса.

![component](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/component.png)

* Компонентные тесты: ограничивают область тестируемого программного 
  обеспечения частью тестируемой системы, манипулируя системой через внутренние 
  интерфейсы и используя тестовые двойники для изоляции тестируемого кода 
  от других компонентов.

![contract](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/contract.png)

* Контрактные тесты: проверка взаимодействия на границе с внешним сервисом, 
  гарантирующая, что он соответствует контракту, ожидаемому потребляющим 
  сервисом.

![end-to-end](images/Testing%20Strategies%20in%20a%20%20Microservice%20Architecture/end-to-end.png)

* Сквозные тесты: проверка того, что система соответствует внешним требованиям 
  и достигает своих целей, путем тестирования всей системы от начала до конца.
  
