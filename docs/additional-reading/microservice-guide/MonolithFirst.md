# Сначала монолит

3 июня 2015

![Martin Fowler](images/microservices/mf.jpg)

[Мартин Фаулер](https://martinfowler.com/)

[ЭВОЛЮЦИОННЫЙ ДИЗАЙН](https://martinfowler.com/tags/evolutionary%20design.html)
[МИКРОСЕРВИСЫ](https://martinfowler.com/tags/microservices.html)

Когда я слышал истории о командах, использующих [архитектуру микросервисов](https://martinfowler.com/articles/microservices.html), я 
заметил общую закономерность.

1. Почти все успешные истории микросервисов начинались с монолита, который стал 
   слишком большим и был разбит.
2. Почти во всех случаях, когда я слышал о системе, созданной как микросервисная 
   система с нуля, она заканчивалась серьезными проблемами.

Это заставило многих моих коллег утверждать, что **вам не следует начинать 
новый проект на микросервисах, даже если вы уверены, что ваше приложение 
будет достаточно большим, чтобы оно того стоило**.

![path](images/monolith-first/path.png)

Микросервисы — полезная архитектура, но даже их сторонники говорят, что их 
использование влечет за собой значительные издержки [MicroservicePremium](https://martinfowler.com/bliki/MicroservicePremium.html), а это 
означает, что они полезны только в более сложных системах. Эта издержки, по 
сути, стоимость управления набором сервисов, замедлят работу команды, которая 
предпочтёт монолит для более простых приложений. Это приводит к убедительному 
аргументу в пользу стратегии «сначала монолит», когда вы должны изначально 
создавать новое приложение как монолит, даже если вы считаете, что в 
дальнейшем оно может извлечь выгоду из архитектуры микросервисов.

Первая причина этого — классический [YAGNI](https://martinfowler.com/bliki/Yagni.html).
Когда вы начинаете создавать новое приложение, насколько вы уверены, что оно 
будет полезно вашим пользователям? Может быть трудно масштабировать плохо 
спроектированную, но успешную программную систему, но это все же лучше, чем 
наоборот. Как мы теперь понимаем, часто лучший способ узнать, полезна ли идея 
программного обеспечения, — это создать ее упрощенную версию и посмотреть, 
насколько хорошо она работает. На этом первом этапе вам необходимо расставить 
приоритеты по скорости (и, следовательно, по времени цикла для обратной связи), 
поэтому издержки микросервисов — это препятствие, без которого вам лучше обойтись.

Вторая проблема, связанная с разработкой микросервисов с нуля, заключается в 
том, что они хорошо работают только в том случае, если вы придумаете хорошие, 
стабильные границы между сервисами, что по сути является задачей составления 
правильного набора [BoundedContexts](https://martinfowler.com/bliki/BoundedContext.html). Любой рефакторинг функционала между 
сервисами намного сложнее, чем в монолите. Но даже опытные архитекторы, работающие 
в знакомых предметных областях, испытывают большие трудности с определением 
границ в самом начале. Построив сначала монолит, вы сможете выяснить, каковы 
правильные границы, прежде чем переходить к микросервисам. Это также дает вам 
время для разработки [MicroservicePrerequisites](https://martinfowler.com/bliki/MicroservicePrerequisites.html), необходимых для более 
узкоспециализированных сервисов.

Я слышал о разных способах реализации стратегии «сначала монолит». Логичный 
способ — тщательно спроектировать монолит, обращая внимание на модульность 
программного обеспечения, как на границах API, так и на том, как хранятся 
данные. Сделайте это хорошо, и перейти на микросервисы будет относительно 
просто. Однако я чувствовал бы себя гораздо более комфортно с этим подходом, 
если бы слышал приличное количество историй, в которых это работало именно 
так.[[1](https://martinfowler.com/bliki/MonolithFirst.html#footnote-typical-monolith)]

> **Руководство по микросервисам**
> 
> ![microservices](images/monolith-first/microservices-sq.png)
> 
> Мои коллеги и я писали о микросервисах с тех пор, как они впервые попали в 
> поле зрения мира программного обеспечения. На этой странице есть статьи о том, 
> когда использовать микросервисы, о методах, которые вы должны использовать в 
> начале, о том, как их эффективно протестировать и как разложить монолит.
> 
> Мартин Фаулер
> 
> [Читать далее](https://martinfowler.com/microservices)
> 
> [Архитектура приложения](https://martinfowler.com/tags/application%20architecture.html)
> [Веб сервисы](https://martinfowler.com/tags/web%20services.html)
> [Микросервисы](https://martinfowler.com/tags/microservices.html)

Более распространенный подход — начать с монолита и постепенно отделять 
микросервисы по краям. Такой подход может оставить существенный монолит в 
основе архитектуры микросервисов, но большинство новых разработок будет 
происходить в микросервисах, пока монолит находится в относительном покое.

Другой распространенный подход — просто полностью заменить монолит. Мало кто 
смотрит на это как на подход, которым можно гордиться, но есть преимущества в 
построении монолита в качестве [SacrificialArchitecture](https://martinfowler.com/bliki/SacrificialArchitecture.html). Не бойтесь создавать 
монолит, который вы отбросите, особенно если монолит может быстро вывести вас 
на рынок.

Еще один путь, с которым я столкнулся, — начать всего с пары крупномодульных 
сервисов, большего размера, чем те, которые вы ожидаете получить в итоге. 
Используйте эти сервисы общего назначения, чтобы привыкнуть к работе с 
несколькими сервисами, наслаждаясь при этом тем, что такая грубая степень 
детализации уменьшает объем межсервисного рефакторинга, который вам необходимо 
выполнить. Затем, когда границы стабилизируются, разбейте их на более мелкие 
сервисы. [[2](https://martinfowler.com/bliki/MonolithFirst.html#footnote-duolith)]

Хотя большинство моих контактов склоняются к подходу «сначала монолит», [он ни 
в коем случае не единодушен](https://martinfowler.com/articles/dont-start-monolith.html). Контраргумент говорит о том, что, начиная с 
микросервисов, вы сможете привыкнуть к ритму разработки в микросервисной среде.
Чтобы построить монолит достаточно модульным образом, чтобы его можно было 
легко разбить на микросервисы, требуется много, возможно, даже слишком много
дисциплинированности. Начав с микросервисов, вы с самого начала приучите всех к 
разработке в отдельных небольших командах, а разделение команд по границам 
сервисов значительно упрощает масштабирование усилий по разработке, когда вам 
это нужно. Это особенно важно при замене системы, когда у вас больше шансов 
установить достаточно стабильные границы на раннем этапе. Хотя доказательств 
немного, я считаю, что вам не следует начинать с микросервисов, если у вас нет 
достаточного опыта построения системы микросервисов в команде.

Я не чувствую, что у меня есть достаточно жизненных историй, чтобы понять 
следует ли использовать стратегию «монолит-сначала». Микросервисы используются 
не так давно, и есть относительно немного жизненных историй, из которых можно 
извлечь уроки. Так что любые советы по этим темам следует рассматривать как 
предварительные, как бы уверенно они не были аргументированы.

## Дальнейшее чтение
Сэм Ньюман [описывает пример команды](http://samnewman.io/blog/2015/04/07/microservices-for-greenfield/), рассматривающей возможность 
использования микросервисов в новом проекте.

## Примечания

1: Вы не можете предположить, что можете взять произвольную систему и разбить 
ее на микросервисы. Большинство систем приобретают слишком много зависимостей 
между своими модулями и поэтому не могут быть разумно разделены. Я слышал о 
множестве случаев, когда попытка разложить монолит быстро заканчивалась 
беспорядком. Я также слышал о нескольких случаях, когда постепенный путь к 
микросервисам оказался успешным, но в этих случаях для начала требовался 
относительно хороший модульный дизайн.

2: Я полагаю, что строго вам следует называть это «дуолитом», но я думаю, 
что подход следует сути стратегии «сначала монолит»: начните с грубой 
детализации, чтобы получить знания, и позже разделите.

## Благодарности
Я позаимствовал большую часть этих идей у своих коллег: Джеймса Льюиса, Сэма Ньюмана, 
Тиягу Паланисами и Эвана Ботчера. Комментарии Стефана Тилкова к предыдущему 
черновику сыграли ключевую роль в прояснении моих мыслей. Чад Карри создал 
милых глифических драконов. Стивен Лоу, Патрик Куа, Жан Роберт Д'амор, 
Челси Комло, Ашок Субраманиан, Дэн Сивец, Прасанна Пендсе, Киф Моррис, Крис 
Форд и Флориан Селлмайр обсуждали черновики в нашей внутренней рассылке писем.