# Объект-значение

14 ноября 2016

![Martin Fowler](../microservice-guide/images/microservices/mf.jpg)

[Мартин Фаулер](https://martinfowler.com/)

[ПРЕДМЕТНО-ОРИЕНТИРОВАННОЕ ПРОЕКТИРОВАНИЕ](https://martinfowler.com/tags/domain%20driven%20design.html)
[ПРОЕКТИРОВАНИЕ API](https://martinfowler.com/tags/API%20design.html)

При программировании часто полезно представлять вещи в виде составных частей. 
2D-координата состоит из значения x и значения y. Сумма денег состоит из числа 
и валюты. Диапазон дат состоит из начальной и конечной дат, которые сами по 
себе могут быть составными частями года, месяца и дня.

Делая это, я сталкиваюсь с вопросом, являются ли два составных объекта одним и 
тем же. Если у меня есть два объекта типа Точка, которые оба представляют 
декартовы координаты (2,3), имеет смысл рассматривать их как равные. Объекты, 
которые равны из-за значения их свойств, в данном случае их координат x и y, 
называются объектами-значениями.

Но если я не буду осторожен при программировании, я могу не получить такого 
поведения в своих программах.

Скажем, я хочу представить точку в JavaScript.

```js
const p1 = {x: 2, y: 3};
const p2 = {x: 2, y: 3};
assert(p1 !== p2);  // НЕ то что я хочу
```

К сожалению, этот тест выполнится успешно. Это происходит потому, что JavaScript 
проверяет равенство объектов js, просматривая их ссылки, игнорируя содержащиеся 
в них значения.

Во многих ситуациях имеет смысл использовать ссылки, а не значения. Если я 
загружаю и манипулирую кучей заказов на продажу, имеет смысл загружать каждый 
заказ в одно место. Если затем мне нужно посмотреть, находится ли последний 
заказ Алисы в следующей доставке, я могу взять ссылку памяти или идентификатор 
заказа Алисы и посмотреть, есть ли эта ссылка в списке заказов в доставке. Для 
этого теста мне не нужно беспокоиться о том, что в заказе. Точно так же я мог 
бы полагаться на уникальный номер заказа, проверяя, есть ли номер заказа Алисы 
в списке доставки.

Поэтому я считаю полезным думать о двух классах объектов: объектах-значениях и 
ссылочных объекты, в зависимости от того, как я различаю их [[1]](https://martinfowler.com/bliki/ValueObject.html#footnote-entity). 
Мне нужно убедиться, что я знаю, как каждый объект будет обрабатывать равенство, 
и запрограммировать их так, чтобы они вели себя в соответствии с моими 
ожиданиями. То, как я это делаю, зависит от языка программирования, на котором 
я работаю.

Некоторые языки обрабатывают все составные данные как значения. Если я создам 
простое структуру в Clojure, она будет выглядеть так.

```
> (= {:x 2, :y 3} {:x 2, :y 3})
true
```

Это функциональный стиль — рассматривать все как неизменные значения.

Но если я не владею функциональным языком, я все равно могу часто создавать 
объекты-значения. Например, в Java класс точек по умолчанию ведет себя так, как 
мне хотелось бы.

```
assertEquals(new Point(2, 3), new Point(2, 3)); // Java
```

Это работает так, благодаря тому что класс точек переопределяет метод equals по умолчанию с 
помощью тестов для значений. [[2]](https://martinfowler.com/bliki/ValueObject.html#footnote-equals-java-point) 
[[3]](https://martinfowler.com/bliki/ValueObject.html#footnote-java-equals-op)

Я могу сделать что-то подобное в JavaScript.

```js
class Point {
  constructor(x, y) {
    this.x = x;
    this.y = y;
  }
  equals (other) {
    return this.x === other.x && this.y === other.y;
  }
}
const p1 = new Point(2,3);
const p2 = new Point(2,3);
assert(p1.equals(p2));
```

Проблема с JavaScript здесь в том, что этот метод equals, который я определил, 
является загадкой для любой другой библиотеки JavaScript.

```js
const somePoints = [new Point(2,3)];
const p = new Point(2,3);
assert.isFalse(somePoints.includes(p)); // не то что я хотел

// поэтому я делаю так
assert(somePoints.some(i => i.equals(p)));
```

Это не проблема в Java, потому что Object.equals определен в базовой библиотеке, 
и все другие библиотеки используют его для сравнений (== обычно используется 
только для примитивов).

Одним из приятных последствий использования объектов-значений является то, что 
мне не нужно заботиться о том, есть ли у меня ссылка на тот же объект в 
памяти или на другую ссылку с таким же значением. Однако, если я не буду 
осторожен, счастливое невежество может привести к проблеме, которую я 
проиллюстрирую на примере Java.

```
Date retirementDate = new Date(Date.parse("Tue 1 Nov 2016"));

// это значит, что нам нужна вечеринка в честь выхода на пенсию
Date partyDate = retirementDate;

// но это вторник давайте устроим вечеринку на выходных
partyDate.setDate(5);

assertEquals(new Date(Date.parse("Sat 5 Nov 2016")), retirementDate);
// упс, теперь мне нужно проработать на три для больше :-(
```

Это пример ошибки округления, я меняю дату в одном месте, и это имеет последствия, 
выходящие за рамки того, что я ожидал [[4]](https://martinfowler.com/bliki/ValueObject.html#footnote-java-date). Чтобы 
избежать ошибок округления, я следую простому, но важному правилу: **объекты-значения 
должны быть неизменяемыми**. Если я хочу изменить дату вечеринки, я вместо этого 
создаю новый объект.

```
Date retirementDate = new Date(Date.parse("Tue 1 Nov 2016"));
Date partyDate = retirementDate;

// считаем дату неизменяемой
partyDate = new Date(Date.parse("Sat 5 Nov 2016"));

// я всё равно выхожу на пенсию во вторник
assertEquals(new Date(Date.parse("Tue 1 Nov 2016")), retirementDate);
```

Конечно, гораздо проще работать с объектами-значениями как с неизменяемыми, 
если они действительно неизменны. С объектами я обычно могу сделать это, просто 
не предоставляя никаких методов настройки. Итак, мой предыдущий класс JavaScript 
будет выглядеть так: [[5]](https://martinfowler.com/bliki/ValueObject.html#footnote-freeze)

```
class Point {
  constructor(x, y) {
    this._data = {x: x, y: y};
  }
  get x() {return this._data.x;}
  get y() {return this._data.y;}
  equals (other) {
    return this.x === other.x && this.y === other.y;
  }
}
```

Хотя неизменяемость — мой любимый метод, позволяющий избежать ошибок округления, 
их также можно избежать, гарантируя, что присваивания всегда создают копию. 
Некоторые языки предоставляют эту возможность, например структуры в C#.

Следует ли рассматривать понятие как ссылочный объект или объект-значение, зависит 
от вашего контекста. Во многих случаях стоит рассматривать почтовый адрес как 
простую структуру текста с равенством значений. Но более сложная система отображения 
могла бы связать почтовые адреса в сложную иерархическую модель, где ссылки имеют 
больше смысла. Как и в большинстве задач моделирования, разные контексты приводят 
к разным решениям. [[6]](https://martinfowler.com/bliki/ValueObject.html#footnote-address)

Часто рекомендуется заменить обычные примитивы, такие как строки, соответствующими 
объектами-значениями. Хотя я могу представить телефонный номер в виде строки, 
превращение в объект телефонного номера делает переменные и параметры более явными 
(с проверкой типов, когда это поддерживается языком), естественным фокусом для 
проверки и позволяет избежать неприемлемого поведения (например, выполнения 
арифметических операций над целыми идентификационными номерами).

Небольшие объекты, такие как точки, деньги или диапазоны, являются хорошими 
примерами объектов-значений. Но более крупные структуры часто могут быть 
запрограммированы как объекты-значения, если они не имеют какой-либо концептуальной 
идентичности или не нуждаются в общих ссылках в программе. Это более естественно 
для функциональных языков, которые по умолчанию неизменяемы. [[7]](https://martinfowler.com/bliki/ValueObject.html#footnote-immutable-reference)

Я обнаружил, что объекты-значения, особенно маленькие, часто упускают из виду, 
считая их слишком тривиальными, чтобы о них стоило думать. Но как только я определил 
хороший набор объектов-значений, я обнаружил, что могу создать богатое поведение над 
ними. Чтобы попробовать это, попробуйте использовать [класс Range](https://martinfowler.com/eaaDev/Range.html) и посмотрите, как 
он предотвращает всю возню с дублированием начальных и конечных атрибутов, 
используя более богатое поведение. Я часто сталкиваюсь с кодовыми базами, в 
которых такие объекты-значения предметной области, как этот, могут выступать в 
качестве цели рефакторинга, что приводит к радикальному упрощению системы. Такое 
упрощение часто удивляет людей, пока они не увидят его несколько раз — к тому 
времени объект-значение — это хороший друг.

## Благодарности

Джеймс Шор, Бет Андрес-Бек и Пит Ходжсон поделились своим опытом использования 
объектов-значений в JavaScript.

Грехам Брукс, Джеймс Бирни, Жерон Соетерс, Мариано Гиуффрида, Маттео Ваккари, Рикардо
Кавальканти и Стивен Лоу оставили ценные комментарии в наших внутренних списках 
рассылки.

## Дальнейшее чтение

Описание Вона Вернона, вероятно, является [лучшим подробным описанием 
объектов-значений](https://www.amazon.com/gp/product/0321834577/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321834577&linkCode=as2&tag=martinfowlerc-20) с точки зрения DDD. Он рассказывает, что стоит выбирать объект-значение 
или сущность, даёт советы по реализации и методы сохранения объектов-значений.

Термин начал набирать обороты в начале нулевых. Две книги, рассказывающие о них 
того времени, — это [PoEAA](https://martinfowler.com/books/eaa.html) и [DDD](https://www.amazon.com/gp/product/0321125215/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321125215&linkCode=as2&tag=martinfowlerc-20). Также было интересное обсуждение на [Ward's Wiki](http://c2.com/cgi/wiki?ValueObject).

Одним из источников терминологической путаницы является то, что на рубеже веков 
в некоторой литературе по J2EE вместо [объекта передачи данных](https://martinfowler.com/eaaCatalog/dataTransferObject.html) использовался 
«объект-значение». Это использование в основном исчезло к настоящему времени, 
но вы можете столкнуться с ним.

## Примечания

1: В предметно-ориентированном проектировании [классификация Эванса](https://martinfowler.com/bliki/EvansClassification.html) 
   противопоставляет объекты-значения сущностям. Я считаю сущности распространенной формой ссылочного 
   объекта, но использую термин «сущность» только в моделях предметной области, в то 
   время как дихотомия объекта ссылка/значение полезна для всего кода.

2: Строго это делается в awt.geom.Point2D, который является суперклассом awt.Point.

3: Большинство сравнений объектов в Java выполняются с помощью равенства, что само 
   по себе немного неудобно, так как я должен помнить, что нужно использовать это, 
   а не оператор равенства ==. Это раздражает, но программисты на Java быстро к этому 
   привыкают, поскольку String ведет себя точно так же. Другие OO языки могут избежать 
   этого - Ruby использует оператор ==, но позволяет его переопределить.

4: Существует серьезная конкуренция за худшую особенность системы даты и времени 
   до Java-8, но мой голос был бы за эту. К счастью, теперь мы можем избежать 
   большей части этого с помощью пакета java.time в Java 8.

5: Это не является строго неизменным, поскольку клиент может манипулировать 
   свойством `_data`. Но достаточно дисциплинированная команда может сделать его 
   неизменным на практике. Если я был обеспокоен тем, что команда не будет 
   достаточно дисциплинированной, я мог использовать `freeze`. Действительно, я мог 
   бы просто использовать `freeze` для простого объекта JavaScript, но я предпочитаю 
   явно использовать класс с объявленными методами доступа.

6: Это больше обсуждается в [книге DDD Эванса](https://www.amazon.com/gp/product/0321125215/ref=as_li_tl?ie=UTF8&camp=1789&creative=9325&creativeASIN=0321125215&linkCode=as2&tag=martinfowlerc-20).

7: Неизменяемость ценна и для ссылочных объектов — если заказ на продажу не изменяется 
   во время запроса на получение, то полезно сделать его неизменяемым; и это сделало 
   бы его безопасным для копирования, если бы это было полезно. Но это не сделает 
   заказ на продажу объектом-значением, если я определяю равенство на основе 
   уникального номера заказа.